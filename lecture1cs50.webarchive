bplist00Ñ_WebMainResourceÕ	
_WebResourceData_WebResourceMIMEType_WebResourceTextEncodingName^WebResourceURL_WebResourceFrameNameOüÿ<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2022.2">
  <style type="text/css">
    li.li1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #0000e9}
    li.li2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9}
    li.li4 {margin: 0.0px 0.0px 12.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    li.li5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; color: #000000; -webkit-text-stroke: #000000}
    li.li6 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Courier; color: #000000; -webkit-text-stroke: #000000}
    li.li7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Courier; color: #000000}
    li.li8 {margin: 0.0px 0.0px 12.0px 0.0px; font: 12.0px Courier; color: #000000; -webkit-text-stroke: #000000}
    span.s1 {text-decoration: underline ; font-kerning: none; -webkit-text-stroke: 0px #0000e9}
    span.s2 {-webkit-text-stroke: 0px #000000}
    span.s3 {text-decoration: underline ; font-kerning: none}
    span.s4 {font: 18.0px Times; text-decoration: underline ; font-kerning: none}
    span.s5 {font-kerning: none}
    span.s6 {text-decoration: underline ; font-kerning: none; color: #0000e9; -webkit-text-stroke: 0px #0000e9}
    span.s7 {font: 12.0px Courier; font-kerning: none}
    span.s8 {font: 12.0px Courier; -webkit-text-stroke: 0px #000000}
    span.s9 {font: 12.0px Times; font-kerning: none}
    span.s10 {font: 12.0px Times; -webkit-text-stroke: 0px #000000}
    span.s11 {font: 24.0px Times; text-decoration: underline ; font-kerning: none}
    ul.ul1 {list-style-type: disc}
    ul.ul2 {list-style-type: circle}
    ul.ul3 {list-style-type: square}
  </style>
</head>
<body>
<ul class="ul1">
  <li class="li1"><a href="https://cs50.harvard.edu/x/2021/notes/1/#c"><span class="s1">C</span></a></li>
  <li class="li2"><span class="s2"><a href="https://cs50.harvard.edu/x/2021/notes/1/#cs50-ide"><span class="s3">CS50 IDE</span></a></span></li>
  <li class="li2"><span class="s2"><a href="https://cs50.harvard.edu/x/2021/notes/1/#compiling"><span class="s3">Compiling</span></a></span></li>
  <li class="li2"><span class="s2"><a href="https://cs50.harvard.edu/x/2021/notes/1/#functions-and-arguments"><span class="s3">Functions and arguments</span></a></span></li>
  <li class="li2"><span class="s2"><a href="https://cs50.harvard.edu/x/2021/notes/1/#main-header-files"><span class="s3">main, header files</span></a></span></li>
  <li class="li2"><span class="s2"><a href="https://cs50.harvard.edu/x/2021/notes/1/#tools"><span class="s3">Tools</span></a></span></li>
  <li class="li2"><span class="s2"><a href="https://cs50.harvard.edu/x/2021/notes/1/#commands"><span class="s3">Commands</span></a></span></li>
  <li class="li2"><span class="s2"><a href="https://cs50.harvard.edu/x/2021/notes/1/#types-format-codes"><span class="s3">Types, format codes,</span></a></span></li>
  <li class="li2"><span class="s2"><a href="https://cs50.harvard.edu/x/2021/notes/1/#operators-limitations-truncation"><span class="s3">Operators, limitations, truncation</span></a></span></li>
  <li class="li2"><span class="s2"><a href="https://cs50.harvard.edu/x/2021/notes/1/#variables-syntactic-sugar"><span class="s3">Variables, syntactic sugar</span></a></span></li>
  <li class="li2"><span class="s2"><a href="https://cs50.harvard.edu/x/2021/notes/1/#conditions"><span class="s3">Conditions</span></a></span></li>
  <li class="li2"><span class="s2"><a href="https://cs50.harvard.edu/x/2021/notes/1/#boolean-expressions-loops"><span class="s3">Boolean expressions, loops</span></a></span></li>
  <li class="li2"><span class="s2"><a href="https://cs50.harvard.edu/x/2021/notes/1/#abstraction"><span class="s3">Abstraction</span></a></span></li>
  <li class="li2"><span class="s2"><a href="https://cs50.harvard.edu/x/2021/notes/1/#mario"><span class="s3">Mario</span></a></span></li>
  <li class="li2"><span class="s2"><a href="https://cs50.harvard.edu/x/2021/notes/1/#memory-imprecision-and-overflow"><span class="s3">Memory, imprecision, and overflow</span></a></span></li>
</ul>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s3"><a href="https://cs50.harvard.edu/x/2021/notes/1/#c"><b>C</b><span class="s4"><b></b></span></a></span></h2>
<ul class="ul1">
  <li class="li4"><span class="s2"></span><span class="s5">Today weâ€™ll learn a new language,Â <b>C</b>: a programming language that has all the features of Scratch and more, but perhaps a little less friendly since itâ€™s purely in text:<br>
`#include &lt;stdio.h&gt;<br>
int main(void) { printf("hello, world"); }`<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">Though at first, to borrow a phrase from MIT, trying to absorb all these new concepts may feel like drinking from a fire hose, be assured that by the end of the semester weâ€™ll be empowered by and experienced at learning and applying these concepts.<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">We can compare a lot of the programming features in C to blocks weâ€™ve already seen and used in Scratch. The details of the syntax are far less important than the ideas, which weâ€™ve already been introduced to.<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">In our example, though the words are new, the ideas are exactly as same as the â€œwhen green flag clickedâ€ and â€œsay (hello, world)â€ blocks in Scratch:<br>
<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">When writing code, we might consider the following qualities:</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s2"><b></b></span><span class="s5"><b>Correctness</b>, or whether our code works correctly, as intended.</span></li>
    <li class="li5"><span class="s2"><b></b></span><span class="s5"><b>Design</b>, or a subjective measure of how well-written our code is, based on how efficient it is and how elegant or logically readable it is, without unnecessary repetition.</span></li>
    <li class="li5"><span class="s2"><b></b></span><span class="s5"><b>Style</b>, or how aesthetically formatted our code is, in terms of consistent indentation and other placement of symbols. Differences in style donâ€™t affect the correctness or meaning of our code, but affect how readable it is visually.</span></li>
  </ul>
</ul>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s3"><a href="https://cs50.harvard.edu/x/2021/notes/1/#cs50-ide"><b>CS50 IDE</b><span class="s4"><b></b></span></a></span></h2>
<ul class="ul1">
  <li class="li4"><span class="s2"></span><span class="s5">To start writing our code quickly, weâ€™ll use a tool for the course,Â <a href="https://ide.cs50.io/"><span class="s6"><b>CS50 IDE</b></span></a>, anÂ <i>integrated development environment</i>Â which includes programs and features for writing code. CS50 IDE is built atop a popular cloud-based IDE used by general programmers, but with additional educational features and customization.<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">Weâ€™ll open the IDE, and after logging in weâ€™ll see a screen like this:<br>
</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s2"></span><span class="s5">The top panel, blank, will contain text files within which we can write our code.</span></li>
    <li class="li5"><span class="s2"></span><span class="s5">The bottom panel, aÂ <b>terminal</b>window, will allow us to type in various commands and run them, including programs from our code above.</span></li>
  </ul>
  <li class="li4"><span class="s2"></span><span class="s5">Our IDE runs in the cloud and comes with a standard set of tools, but know that there are many desktop-based IDEs as well, offering more customization and control for different programming purposes, at the cost of greater setup time and effort.<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">In the IDE, weâ€™ll go to File &gt; New File, and then File &gt; Save to save our file asÂ </span><span class="s7">hello.c</span><span class="s5">, indicating that our file will be code written in C. Weâ€™ll see that the name of our tab has indeed changed toÂ </span><span class="s7">hello.c</span><span class="s5">, and now weâ€™ll paste our code from above:<br>
`#include &lt;stdio.h&gt;<br>
int main(void) { printf("hello, world"); }`<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">To run our program, weâ€™ll use a CLI, orÂ <b>command-line interface</b>, a prompt at which we need to enter text commands. This is in contrast to aÂ <b>graphical user interface</b>, or GUI, like Scratch, where we have images, icons, and buttons in addition to text.<br>
</span></li>
</ul>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s3"><a href="https://cs50.harvard.edu/x/2021/notes/1/#compiling"><b>Compiling</b><span class="s4"><b></b></span></a></span></h2>
<ul class="ul1">
  <li class="li5"><span class="s2"></span><span class="s5">In the terminal in the bottom pane of our IDE, weâ€™llÂ <b>compile</b>Â our code before we can run it. Computers only understand binary, which is also used to represent instructions like printing something to the screen. OurÂ <b>source code</b>Â has been written in characters we can read, but it needs to be compiled: converted toÂ <b>machine code</b>, patterns of zeros and ones that our computer can directly understand.</span></li>
  <li class="li5"><span class="s2"></span><span class="s5">A program called aÂ <b>compiler</b>Â will take source code as input and produce machine code as output. In the CS50 IDE, we have access to a compiler already, through a command calledÂ <b>make</b>. In our terminal, weâ€™ll type inÂ </span><span class="s7">make hello</span><span class="s5">, which will automatically find ourÂ </span><span class="s7">hello.c</span><span class="s5">Â file with our source code, and compile it into a program calledÂ </span><span class="s7">hello</span><span class="s5">. There will be some output, but no error messages in yellow or red, so our program compiled successfully.</span></li>
  <li class="li5"><span class="s2"></span><span class="s5">To run our program, weâ€™ll type in another command,Â </span><span class="s7">./hello</span><span class="s5">, which looks in the current folder,Â </span><span class="s7">.</span><span class="s5">, for a program calledÂ </span><span class="s7">hello</span><span class="s5">, and runs it.</span></li>
  <li class="li5"><span class="s2"></span><span class="s5">TheÂ </span><span class="s7">$</span><span class="s5">Â in the terminal is an indicator of where the prompt is, or where we can type in more commands.</span></li>
</ul>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s3"><a href="https://cs50.harvard.edu/x/2021/notes/1/#functions-and-arguments"><b>Functions and arguments</b><span class="s4"><b></b></span></a></span></h2>
<ul class="ul1">
  <li class="li4"><span class="s2"></span><span class="s5">Weâ€™ll use the same ideas weâ€™ve explored in Scratch.<br>
</span></li>
  <li class="li4"><span class="s2"><b></b></span><span class="s5"><b>Functions</b>Â are small actions or verbs that we can use in our program to do something, and the inputs to functions are calledÂ <b>arguments</b>.</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s2"></span><span class="s5">For example, the â€œsayâ€ block in Scratch might have taken something like â€œhello, worldâ€ as an argument. In C, the function to print something to the screen is calledÂ </span><span class="s7">printf</span><span class="s5">Â (with theÂ </span><span class="s7">f</span><span class="s5">Â standing for â€œformattedâ€ text, which weâ€™ll soon see). And in C, we pass in arguments within parentheses, as inÂ </span><span class="s7">printf("hello, world");</span><span class="s5">. The double quotes indicate that we want to print out the lettersÂ </span><span class="s7">hello, world</span><span class="s5">Â literally, and the semicolon at the end indicates the end of our line of code.</span></li>
  </ul>
  <li class="li4"><span class="s2"></span><span class="s5">Functions can also have two kinds of outputs:</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s2"><b></b></span><span class="s5"><b>side effects</b>, such as something printed to the screen,</span></li>
    <li class="li5"><span class="s2"></span><span class="s5">andÂ <b>return values</b>, a value that is passed back to our program that we can use or store for later.</span></li>
    <ul class="ul3">
      <li class="li5"><span class="s2"></span><span class="s5">The â€œaskâ€ block in Scratch, for example, created an â€œanswerâ€ block.</span></li>
    </ul>
  </ul>
  <li class="li4"><span class="s2"></span><span class="s5">To get the same functionality as the â€œaskâ€ block, weâ€™ll use aÂ <b>library</b>, or a set of code already written. The CS50 Library will include some basic, simple functions that we can use right away. For example,Â </span><span class="s7">get_string</span><span class="s5">Â will ask the user for aÂ <b>string</b>, or some sequence of text, and return it to our program.Â </span><span class="s7">get_string</span><span class="s5">Â takes in some input as the prompt for the user, such asÂ </span><span class="s7">What's your name?</span><span class="s5">, and weâ€™ll have to save it in a variable with:<br>
</span><span class="s7">string answer = get_string("What's your name? ");</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s2"></span><span class="s5">In C, the singleÂ </span><span class="s7">=</span><span class="s5">Â indicatesÂ <b>assignment</b>, or setting the value on the right to the variable on the left. And C will call theÂ </span><span class="s7">get_string</span><span class="s5">function in order to get its output first.</span></li>
    <li class="li5"><span class="s2"></span><span class="s5">And we also need to indicate that our variable namedÂ </span><span class="s7">answer</span><span class="s5">Â has aÂ <b>type</b>Â of string, so our program knows to interpret the zeros and ones as text.</span></li>
    <li class="li5"><span class="s2"></span><span class="s5">Finally, we need to remember to add a semicolon to end our line of code.</span></li>
  </ul>
  <li class="li4"><span class="s2"></span><span class="s5">In Scratch, we also used the â€œanswerâ€ block within our â€œjoinâ€ and â€œsayâ€ blocks. In C, weâ€™ll do this:<br>
</span><span class="s7">printf("hello, %s", answer);</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s2"></span><span class="s5">TheÂ </span><span class="s7">%s</span><span class="s5">Â is called aÂ <b>format code</b>, which just means that we want theÂ </span><span class="s7">printf</span><span class="s5">Â function to substitute a variable where theÂ </span><span class="s7">%s</span><span class="s5">Â placeholder is. And the variable we want to use isÂ </span><span class="s7">answer</span><span class="s5">, which we give toÂ </span><span class="s7">printf</span><span class="s5">Â as another argument, separated from the first one with a comma. (</span><span class="s7">printf("hello, answer")</span><span class="s5">Â would literally print outÂ </span><span class="s7">hello, answer</span><span class="s5">Â every time.)</span></li>
  </ul>
  <li class="li4"><span class="s2"></span><span class="s5">Back in the CS50 IDE, weâ€™ll add what weâ€™ve discovered:<br>
`#include &lt;cs50.h&gt; #include &lt;stdio.h&gt;<br>
int main(void) { string answer = get_string("What's your name? "); printf("hello, %s", answer); }`</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s2"></span><span class="s5">We need to tell the compiler to include the CS50 Library, withÂ </span><span class="s7">#include &lt;cs50.h&gt;</span><span class="s5">, so we can use theÂ </span><span class="s7">get_string</span><span class="s5">Â function.</span></li>
    <li class="li5"><span class="s2"></span><span class="s5">We also have an opportunity to use better style here, since we could name ourÂ </span><span class="s7">answer</span><span class="s5">Â variable anything, but a more descriptive name will help us understand its purpose better than a shorter name likeÂ </span><span class="s7">a</span><span class="s5">Â orÂ </span><span class="s7">x</span><span class="s5">.</span></li>
  </ul>
  <li class="li4"><span class="s2"></span><span class="s5">After we save the file, weâ€™ll need to recompile our program withÂ </span><span class="s7">make hello</span><span class="s5">, since weâ€™ve only changed the source code but not the compiled machine code. Other languages or IDEs may not require us to manually recompile our code after we change it, but here we have the opportunity for more control and understanding of whatâ€™s happening under the hood.<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">Now,Â </span><span class="s7">./hello</span><span class="s5">Â will run our program, and prompt us for our name as intended. We might notice that the next prompt is printed immediately after our programâ€™s output, as inÂ </span><span class="s7">hello, Brian~/ $</span><span class="s5">. We can add a new line after our programâ€™s output, so the next prompt is on its own line, withÂ </span><span class="s7">\\n</span><span class="s5">:<br>
</span><span class="s7">printf("hello, %s\\n", answer);</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s8"></span><span class="s7">\\n</span><span class="s5">Â is an example of anÂ <b>escape sequence</b>, or some text that represents some other text.</span></li>
  </ul>
</ul>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s3"><a href="https://cs50.harvard.edu/x/2021/notes/1/#main-header-files"><b>main, header files</b><span class="s4"><b></b></span></a></span></h2>
<ul class="ul1">
  <li class="li4"><span class="s2"></span><span class="s5">The â€œwhen green flag clickedâ€ block in Scratch starts what we would consider to be the main program. In C, the first line for the same isÂ </span><span class="s7">int main(void)</span><span class="s5">, which weâ€™ll learn more about over the coming weeks, followed by an open curly braceÂ </span><span class="s7">{</span><span class="s5">, and a closed curly braceÂ </span><span class="s7">}</span><span class="s5">, wrapping everything that should be in our program.<br>
`int main(void) {<br>
}`</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s2"></span><span class="s5">Weâ€™ll learn more about ways we can modify this line in the coming weeks, but for now weâ€™ll simply use this to start our program.</span></li>
  </ul>
  <li class="li4"><span class="s2"><b></b></span><span class="s5"><b>Header files</b>Â that end withÂ </span><span class="s7">.h</span><span class="s5">Â refer to some other set of code, like a library, that we can then use in our program. WeÂ <i>include</i>Â them with lines likeÂ </span><span class="s7">#include &lt;stdio.h&gt;</span><span class="s5">, for example, for theÂ <i>standard input/output</i>Â library, which contains theÂ </span><span class="s7">printf</span><span class="s5">Â function.<br>
</span></li>
</ul>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s3"><a href="https://cs50.harvard.edu/x/2021/notes/1/#tools"><b>Tools</b><span class="s4"><b></b></span></a></span></h2>
<ul class="ul1">
  <li class="li4"><span class="s2"></span><span class="s5">With all of the new syntax, itâ€™s easy for us to make mistakes or forget something. We have a few tools written by the staff to help us.<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">We might forget to include a line of code, and when we try to compile our program, see a lot of lines of error messages that are hard to understand, since the compiler might have been designed for a more technical audience.Â </span><span class="s7"><b>help50</b></span><span class="s5">Â is a command we can run to explain problems in our code in a more user-friendly way. We can run it by addingÂ </span><span class="s7">help50</span><span class="s5">Â to the front of a command weâ€™re trying, likeÂ </span><span class="s7">help50 make hello</span><span class="s5">, to get advice that might be more understandable.<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">It turns out that, in C, new lines and indentation generally donâ€™t affect how our code runs. For example, we can change ourÂ </span><span class="s7">main</span><span class="s5">Â function to be one line,Â </span><span class="s7">int main(void){printf("hello, world");}</span><span class="s5">, but itâ€™s much harder to read, so we would consider it to have bad style. We can runÂ </span><span class="s7"><b>style50</b></span><span class="s5">, as withÂ </span><span class="s7">style50 hello.c</span><span class="s5">, with the name of the file of our source code, to see suggestions for new lines and indentation.<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">Additionally, we can addÂ <b>comments</b>, notes in our source code for ourselves or other humans that donâ€™t affect how our code runs. For example, we might add a line likeÂ </span><span class="s7">// Greet user</span><span class="s5">, with two slashesÂ </span><span class="s7">//</span><span class="s5">Â to indicate that the line is a comment, and then write the purpose of our code or program to help us remember later on.<br>
</span></li>
  <li class="li4"><span class="s8"><b></b></span><span class="s7"><b>check50</b></span><span class="s5">Â will check the correctness of our code with some automated tests. The staff writes tests specifically for some of the programs weâ€™ll be writing in the course, and instructions for usingÂ </span><span class="s7">check50</span><span class="s5">Â will be included in each problem set or lab as needed. After we runÂ </span><span class="s7">check50</span><span class="s5">, weâ€™ll see some output telling us whether our code passed relevant tests.<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">The CS50 IDE also gives us the equivalent of our own computer in the cloud, somewhere on the internet, with our own files and folders. If we click the folder icon in the top left, weâ€™ll see a file tree, a GUI of the files in our IDE:<br>
</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s2"></span><span class="s5">To open a file, we can just double-click it.Â </span><span class="s7">hello.c</span><span class="s5">Â is the source code that we just wrote, andÂ </span><span class="s7">hello</span><span class="s5">Â itself will have lots of red dots, each of which are unprintable characters since they represent binary instructions for our computers.</span></li>
  </ul>
</ul>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s3"><a href="https://cs50.harvard.edu/x/2021/notes/1/#commands"><b>Commands</b><span class="s4"><b></b></span></a></span></h2>
<ul class="ul1">
  <li class="li4"><span class="s2"></span><span class="s5">Since the CS50 IDE is a virtual computer in the cloud, we can also run commands available in Linux, an operating system like macOS or Windows.<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">In the terminal, we can type inÂ </span><span class="s7">ls</span><span class="s5">, short for list, to see a list of files and folder in the current folder:<br>
</span><span class="s7">~/ $ ls hello* hello.c</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s8"></span><span class="s7">hello</span><span class="s5">Â is in green with an asterisk to indicate that we can run it as a program.</span></li>
  </ul>
  <li class="li4"><span class="s2"></span><span class="s5">We can alsoÂ <i>remove</i>Â files withÂ </span><span class="s7">rm</span><span class="s5">, with a command likeÂ </span><span class="s7">rm hello</span><span class="s5">. It will prompt us for a confirmation, and we can respond withÂ </span><span class="s7">y</span><span class="s5">Â orÂ </span><span class="s7">n</span><span class="s5">Â for yes or no.<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">WithÂ </span><span class="s7">mv</span><span class="s5">, orÂ <i>move</i>, we can rename files. WithÂ </span><span class="s7">mv hello.c goodbye.c</span><span class="s5">, weâ€™ve renamed ourÂ </span><span class="s7">hello.c</span><span class="s5">Â file to be namedÂ </span><span class="s7">goodbye.c</span><span class="s5">.<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">WithÂ </span><span class="s7">mkdir</span><span class="s5">, orÂ <i>make directory</i>, we can create folders, or directories. If we runÂ </span><span class="s7">mkdir lecture</span><span class="s5">, weâ€™ll see a folder calledÂ </span><span class="s7">lecture</span><span class="s5">, and we can move files into directories with a command likeÂ </span><span class="s7">mv hello.c lecture/</span><span class="s5">.<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">ToÂ <i>change directories</i>Â in our terminal, we can useÂ </span><span class="s7">cd</span><span class="s5">, as withÂ </span><span class="s7">cd lecture/</span><span class="s5">. Our prompt will change fromÂ </span><span class="s7">~/</span><span class="s5">Â toÂ </span><span class="s7">~/lecture/</span><span class="s5">, indicating that weâ€™re in theÂ </span><span class="s7">lecture</span><span class="s5">Â directory insideÂ </span><span class="s7">~</span><span class="s5">.Â </span><span class="s7">~</span><span class="s5">Â stands for our home directory, or our accountâ€™s default, top-level folder.<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">We can also useÂ </span><span class="s7">..</span><span class="s5">Â as shorthand for the parent, or containing folder. WithinÂ </span><span class="s7">~/lecture/</span><span class="s5">, we can runÂ </span><span class="s7">mv hello.c ..</span><span class="s5">Â to move it back up toÂ </span><span class="s7">~</span><span class="s5">, since itâ€™s the parent folder ofÂ </span><span class="s7">lecture/</span><span class="s5">.Â </span><span class="s7">cd ..</span><span class="s5">, similarly, will change our terminalâ€™s directory to the current oneâ€™s parent. A single dot,Â </span><span class="s7">.</span><span class="s5">, refers to the current directory, as inÂ </span><span class="s7">./hello</span><span class="s5">.<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">Now that ourÂ </span><span class="s7">lecture/</span><span class="s5">Â folder is empty, we can remove it withÂ </span><span class="s7">rmdir lecture/</span><span class="s5">as well.<br>
</span></li>
</ul>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s3"><a href="https://cs50.harvard.edu/x/2021/notes/1/#types-format-codes"><b>Types, format codes,</b><span class="s4"><b></b></span></a></span></h2>
<ul class="ul1">
  <li class="li5"><span class="s2"></span><span class="s5">There are many dataÂ <b>types</b>Â we can use for our variables, which indicate to the computer what type of data they represent:</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s8"></span><span class="s7">bool</span><span class="s5">, a Boolean expression of eitherÂ </span><span class="s7">true</span><span class="s5">Â orÂ </span><span class="s7">false</span></li>
    <li class="li5"><span class="s8"></span><span class="s7">char</span><span class="s5">, a single ASCII character likeÂ </span><span class="s7">a</span><span class="s5">Â orÂ </span><span class="s7">2</span></li>
    <li class="li5"><span class="s8"></span><span class="s7">double</span><span class="s5">, a floating-point value with more digits than aÂ </span><span class="s7">float</span></li>
    <li class="li5"><span class="s8"></span><span class="s7">float</span><span class="s5">, a floating-point value, or real number with a decimal value</span></li>
    <li class="li5"><span class="s8"></span><span class="s7">int</span><span class="s5">, integers up to a certain size, or number of bits</span></li>
    <li class="li5"><span class="s8"></span><span class="s7">long</span><span class="s5">, integers with more bits, so they can count higher than anÂ </span><span class="s7">int</span></li>
    <li class="li5"><span class="s8"></span><span class="s7">string</span><span class="s5">, a string of characters</span></li>
  </ul>
  <li class="li5"><span class="s2"></span><span class="s5">And the CS50 library has corresponding functions to get input of various types:</span></li>
  <ul class="ul2">
    <li class="li6"><span class="s2"></span><span class="s5">get_char</span></li>
    <li class="li6"><span class="s2"></span><span class="s5">get_double</span></li>
    <li class="li6"><span class="s2"></span><span class="s5">get_float</span></li>
    <li class="li6"><span class="s2"></span><span class="s5">get_int</span></li>
    <li class="li6"><span class="s2"></span><span class="s5">get_long</span></li>
    <li class="li6"><span class="s2"></span><span class="s5">get_string</span></li>
  </ul>
  <li class="li5"><span class="s2"></span><span class="s5">ForÂ </span><span class="s7">printf</span><span class="s5">, too, there are different placeholders for each type:</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s8"></span><span class="s7">%c</span><span class="s5">Â for chars</span></li>
    <li class="li5"><span class="s8"></span><span class="s7">%f</span><span class="s5">Â for floats, doubles</span></li>
    <li class="li5"><span class="s8"></span><span class="s7">%i</span><span class="s5">Â for ints</span></li>
    <li class="li5"><span class="s8"></span><span class="s7">%li</span><span class="s5">Â for longs</span></li>
    <li class="li5"><span class="s8"></span><span class="s7">%s</span><span class="s5">Â for strings</span></li>
  </ul>
</ul>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s3"><a href="https://cs50.harvard.edu/x/2021/notes/1/#operators-limitations-truncation"><b>Operators, limitations, truncation</b><span class="s4"><b></b></span></a></span></h2>
<ul class="ul1">
  <li class="li4"><span class="s2"></span><span class="s5">There are several mathematical operators we can use, too:</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s8"></span><span class="s7">+</span><span class="s5">Â for addition</span></li>
    <li class="li5"><span class="s2"></span><span class="s5">``Â for subtraction</span></li>
    <li class="li5"><span class="s2"></span><span class="s5">``Â for multiplication</span></li>
    <li class="li5"><span class="s8"></span><span class="s7">/</span><span class="s5">Â for division</span></li>
    <li class="li5"><span class="s8"></span><span class="s7">%</span><span class="s5">Â for remainder</span></li>
  </ul>
  <li class="li4"><span class="s2"></span><span class="s5">Weâ€™ll make a new program,Â </span><span class="s7">addition.c</span><span class="s5">:<br>
`#include &lt;cs50.h&gt; #include &lt;stdio.h&gt;<br>
int main(void) { int x = get_int("x: ");<br>
</span><span class="s7"><span class="Apple-converted-space">Â  </span>int y = get_int("y: ");</span></li>
  <li class="li7"></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>printf("%i\\n", x + y);</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><br>
</span><span class="s9">}`</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s2"></span><span class="s5">Weâ€™ll include header files for libraries we know we want to use, and then weâ€™ll callÂ </span><span class="s7">get_int</span><span class="s5">Â to get integers from the user, storing them in variables namedÂ </span><span class="s7">x</span><span class="s5">Â andÂ </span><span class="s7">y</span><span class="s5">.</span></li>
    <li class="li5"><span class="s2"></span><span class="s5">Then, inÂ </span><span class="s7">printf</span><span class="s5">, weâ€™ll print a placeholder for an integer,Â </span><span class="s7">%i</span><span class="s5">, followed by a new line. Since we want to print out the sum ofÂ </span><span class="s7">x</span><span class="s5">Â andÂ </span><span class="s7">y</span><span class="s5">, weâ€™ll pass inÂ </span><span class="s7">x + y</span><span class="s5">Â forÂ </span><span class="s7">printf</span><span class="s5">to substitute in the string.</span></li>
    <li class="li5"><span class="s2"></span><span class="s5">Weâ€™ll save, runÂ </span><span class="s7">make addition</span><span class="s5">Â in the terminal, and thenÂ </span><span class="s7">./addition</span><span class="s5">to see our program working. If we type in something thatâ€™s not an integer, weâ€™ll seeÂ </span><span class="s7">get_int</span><span class="s5">Â asking us for an integer again. If we type in a really big number, likeÂ </span><span class="s7">4000000000</span><span class="s5">,Â </span><span class="s7">get_int</span><span class="s5">Â will prompt us again too. This is because, like on many computer systems, anÂ </span><span class="s7">int</span><span class="s5">Â in CS50 IDE is 32 bits, which can only contain about four billion different values. And since integers can be positive or negative, the highest positive value for anÂ </span><span class="s7">int</span><span class="s5">Â can only be about two billion, with a lowest negative value of about negative two billion, for a total of about four billion total values.</span></li>
  </ul>
  <li class="li4"><span class="s2"></span><span class="s5">We can change our program to use theÂ </span><span class="s7">long</span><span class="s5">Â type:<br>
`#include &lt;cs50.h&gt; #include &lt;stdio.h&gt;<br>
int main(void) { long x = get_long("x: ");<br>
</span><span class="s7"><span class="Apple-converted-space">Â  </span>long y = get_long("y: ");</span></li>
  <li class="li7"></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>printf("%li\\n", x + y);</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><br>
</span><span class="s9">}`</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s2"></span><span class="s5">Now we can type in bigger integers, and see a correct result as expected.</span></li>
  </ul>
  <li class="li4"><span class="s2"></span><span class="s5">Whenever we get an error while compiling, itâ€™s a good idea to scroll up to the top to see the first error and fix that first, since sometimes a mistake early in the program will lead to the rest of the program being interpreted with errors as well.<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">Letâ€™s look at another example,Â </span><span class="s7">truncation.c</span><span class="s5">:<br>
`#include &lt;cs50.h&gt; #include &lt;stdio.h&gt;<br>
int main(void) { // Get numbers from user int x = get_int("x: "); int y = get_int("y: ");<br>
</span><span class="s7"><span class="Apple-converted-space">Â  </span>// Divide x by y</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>float z = x / y;</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>printf("%f\\n", z);</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><br>
</span><span class="s9">}`</span></li>
  <ul class="ul2">
    <li class="li4"><span class="s2"></span><span class="s5">Weâ€™ll store the result ofÂ </span><span class="s7">x</span><span class="s5">Â divided byÂ </span><span class="s7">y</span><span class="s5">Â inÂ </span><span class="s7">z</span><span class="s5">, a floating-point value, or real number, and print it out as a float too.<br>
</span></li>
    <li class="li4"><span class="s2"></span><span class="s5">But when we compile and run our program, we seeÂ </span><span class="s7">z</span><span class="s5">Â printed out as whole numbers likeÂ </span><span class="s7">0.000000</span><span class="s5">Â orÂ </span><span class="s7">1.000000</span><span class="s5">. It turns out that, in our code,Â </span><span class="s7">x / y</span><span class="s5">Â is divided as two integersÂ <i>first</i>, so the result given back by the division operation is an integer as well. The result isÂ <b>truncated</b>, with the value after the decimal point lost. Even thoughÂ </span><span class="s7">z</span><span class="s5">is aÂ </span><span class="s7">float</span><span class="s5">, the value weâ€™re storing in it is already an integer.<br>
</span></li>
    <li class="li4"><span class="s2"></span><span class="s5">To fix this, weÂ <b>cast</b>, or convert, our integers to floats before we divide them:<br>
</span><span class="s7">float z = (float) x / (float) y;</span><span class="s5"><br>
</span></li>
    <li class="li4"><span class="s2"></span><span class="s5">The result will be a float as we expect, and in fact we can cast only one ofÂ </span><span class="s7">x</span><span class="s5">Â orÂ </span><span class="s7">y</span><span class="s5">Â and get a float as well.<br>
</span></li>
  </ul>
</ul>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s3"><a href="https://cs50.harvard.edu/x/2021/notes/1/#variables-syntactic-sugar"><b>Variables, syntactic sugar</b><span class="s4"><b></b></span></a></span></h2>
<ul class="ul1">
  <li class="li5"><span class="s2"></span><span class="s5">In Scratch, we had blocks like â€œset [counter] to (0)â€ that set aÂ <b>variable</b>Â to some value. In C, we would writeÂ </span><span class="s7">int counter = 0;</span><span class="s5">Â for the same effect.</span></li>
  <li class="li5"><span class="s2"></span><span class="s5">We can increase the value of a variable withÂ </span><span class="s7">counter = counter + 1;</span><span class="s5">, where we look at the right side first, taking the original value ofÂ </span><span class="s7">counter</span><span class="s5">, adding 1, and then storing it into the left side (back intoÂ </span><span class="s7">counter</span><span class="s5">Â in this case).</span></li>
  <li class="li5"><span class="s2"></span><span class="s5">C also supportsÂ <b>syntactic sugar</b>, or shorthand expressions for the same functionality. In this case, we could equivalently sayÂ </span><span class="s7">counter += 1;</span><span class="s5">Â to add one toÂ </span><span class="s7">counter</span><span class="s5">Â before storing it again. We could also just writeÂ </span><span class="s7">counter++;</span><span class="s5">, and we can learn this (and other examples) through looking at documentation or other references online.</span></li>
</ul>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s3"><a href="https://cs50.harvard.edu/x/2021/notes/1/#conditions"><b>Conditions</b><span class="s4"><b></b></span></a></span></h2>
<ul class="ul1">
  <li class="li4"><span class="s2"></span><span class="s5">We can translate conditions, or â€œifâ€ blocks, with:<br>
</span><span class="s7">if (x &lt; y) { printf("x is less than y\\n"); }</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s2"></span><span class="s5">Notice that in C, we useÂ </span><span class="s7">{</span><span class="s5">Â andÂ </span><span class="s7">}</span><span class="s5">(as well as indentation) to indicate how lines of code should be nested.</span></li>
  </ul>
  <li class="li8"><span class="s10"></span><span class="s9">We can have â€œifâ€ and â€œelseâ€ conditions:<br>
</span><span class="s5">if (x &lt; y) { printf("x is less than y\\n"); } else { printf("x is not less than y\\n"); }</span><span class="s9"><br>
</span></li>
  <li class="li8"><span class="s10"></span><span class="s9">And even â€œelse ifâ€:<br>
</span><span class="s5">if (x &lt; y) { printf("x is less than y\\n"); } else if (x &gt; y) { printf("x is greater than y\\n"); } else if (x == y) { printf("x is equal to y\\n"); }</span></li>
  <ul class="ul2">
    <li class="li4"><span class="s2"></span><span class="s5">Notice that, to compare two values in C, we useÂ </span><span class="s7">==</span><span class="s5">, two equals signs.<br>
</span></li>
    <li class="li8"><span class="s10"></span><span class="s9">And, logically, we donâ€™t need theÂ </span><span class="s5">if (x == y)</span><span class="s9">Â in the final condition, since thatâ€™s the only case remaining, so we can just sayÂ </span><span class="s5">else</span><span class="s9">:<br>
</span><span class="s5">if (x &lt; y) { printf("x is less than y\\n"); } else if (x &gt; y) { printf("x is greater than y\\n"); } else { printf("x is equal to y\\n"); }</span><span class="s9"><br>
</span></li>
  </ul>
  <li class="li4"><span class="s2"></span><span class="s5">Letâ€™s take a look at another example,Â </span><span class="s7">conditions.c</span><span class="s5">:<br>
`#include &lt;cs50.h&gt; #include &lt;stdio.h&gt;<br>
int main(void) { // Prompt user for x int x = get_int("x: ");<br>
</span><span class="s7"><span class="Apple-converted-space">Â  </span>// Prompt user for y</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>int y = get_int("y: ");</span></li>
  <li class="li7"></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>// Compare x and y</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>if (x &lt; y)</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>{</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  Â  Â  </span>printf("x is less than y\\n");</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>}</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>else if (x &gt; y)</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>{</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  Â  Â  </span>printf("x is greater than y\\n");</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>}</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>else</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>{</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  Â  Â  </span>printf("x is equal to y\\n");</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>}</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><br>
</span><span class="s9">}`</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s2"></span><span class="s5">Weâ€™ve included the conditions we just saw, along with two calls, or uses, ofÂ </span><span class="s7">get_int</span><span class="s5">Â to getÂ </span><span class="s7">x</span><span class="s5">Â andÂ </span><span class="s7">y</span><span class="s5">from the user.</span></li>
    <li class="li5"><span class="s2"></span><span class="s5">Weâ€™ll compile and run our program to see that it indeed works as intended.</span></li>
  </ul>
  <li class="li4"><span class="s2"></span><span class="s5">InÂ </span><span class="s7">agree.c</span><span class="s5">, we can ask the user to confirm or deny something:<br>
`#include &lt;cs50.h&gt; #include &lt;stdio.h&gt;<br>
int main(void) { char c = get_char("Do you agree? ");<br>
</span><span class="s7"><span class="Apple-converted-space">Â  </span>// Check whether agreed</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>if (c == 'Y' || c == 'y')</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>{</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  Â  Â  </span>printf("Agreed.\\n");</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>}</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>else if (c == 'N' || c == 'n')</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>{</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  Â  Â  </span>printf("Not agreed.\\n");</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>}</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><br>
</span><span class="s9">}`</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s2"></span><span class="s5">WithÂ </span><span class="s7">get_char</span><span class="s5">, we can get a single character, and since we only have a single one in our program, it seems reasonable to call itÂ </span><span class="s7">c</span><span class="s5">.</span></li>
    <li class="li5"><span class="s2"></span><span class="s5">We use two vertical bars,Â </span><span class="s7">||</span><span class="s5">, to indicate a logical â€œorâ€, whether either expression can be true for the condition to be followed. (Two ampersands,Â </span><span class="s7">&amp;&amp;</span><span class="s5">, indicate a logical â€œandâ€, where both conditions would have to be true.) And notice that we use two equals signs,Â </span><span class="s7">==</span><span class="s5">, to compare two values, as well as single quotes,Â </span><span class="s7">'</span><span class="s5">, to surround our values of single characters.</span></li>
    <li class="li5"><span class="s2"></span><span class="s5">If neither of the expressions are true, nothing will happen since our program doesnâ€™t have a loop.</span></li>
  </ul>
</ul>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s3"><a href="https://cs50.harvard.edu/x/2021/notes/1/#boolean-expressions-loops"><b>Boolean expressions, loops</b><span class="s4"><b></b></span></a></span></h2>
<ul class="ul1">
  <li class="li4"><span class="s2"></span><span class="s5">We can translate a â€œforeverâ€ block in Scratch with:<br>
</span><span class="s7">while (true) { printf("hello, world\\n"); }</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s2"></span><span class="s5">TheÂ </span><span class="s7">while</span><span class="s5">Â keyword requires a condition, so we useÂ </span><span class="s7">true</span><span class="s5">Â as the Boolean expression to ensure that our loop will run forever.Â </span><span class="s7">while</span><span class="s5">will tell the computer to check whether the expression evaluates toÂ </span><span class="s7">true</span><span class="s5">, and then run the lines inside the curly braces. Then it will repeat that until the expression isnâ€™t true anymore. In this case,Â </span><span class="s7">true</span><span class="s5">Â will always be true, so our loop is anÂ <b>infinite loop</b>, or one that will run forever.</span></li>
  </ul>
  <li class="li8"><span class="s10"></span><span class="s9">We could do something a certain number of times withÂ </span><span class="s5">while</span><span class="s9">:<br>
</span><span class="s5">int i = 0; while (i &lt; 50) { printf("hello, world\\n"); i++; }</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s2"></span><span class="s5">We create a variable,Â </span><span class="s7">i</span><span class="s5">, and set it to 0. Then, whileÂ </span><span class="s7">i</span><span class="s5">Â is less than 50, we run some lines of code, including one where we add 1 toÂ </span><span class="s7">i</span><span class="s5">Â each time. This way, our loop will eventually end whenÂ </span><span class="s7">i</span><span class="s5">Â reaches a value of 50.</span></li>
    <li class="li5"><span class="s2"></span><span class="s5">In this case, weâ€™re using the variableÂ </span><span class="s7">i</span><span class="s5">Â as a counter, but since it doesnâ€™t serve any additional purpose, we can simply name itÂ </span><span class="s7">i</span><span class="s5">.</span></li>
  </ul>
  <li class="li4"><span class="s2"></span><span class="s5">Even though weÂ <i>could</i>Â do the following and start counting at 1, by convention we should start at 0:<br>
</span><span class="s7">int i = 1; while (i &lt;= 50) { printf("hello, world\\n"); i++; }</span><span class="s5"><br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">Another correct, but arguably less well-designed solution might be starting at 50 and counting backwards:<br>
</span><span class="s7">int i = 50; while (i &gt; 0) { printf("hello, world\\n"); i--; }</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s2"></span><span class="s5">In this case, the logic for our loop is harder to reason about without serving any additional purpose, and might even confuse readers.</span></li>
  </ul>
  <li class="li8"><span class="s10"></span><span class="s9">Finally, more commonly we can use theÂ </span><span class="s5">for</span><span class="s9">Â keyword:<br>
</span><span class="s5">for (int i = 0; i &lt; 50; i++) { printf("hello, world\\n"); }</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s2"></span><span class="s5">Again, first we create a variable namedÂ </span><span class="s7">i</span><span class="s5">Â and set it to 0. Then, we check thatÂ </span><span class="s7">i &lt; 50</span><span class="s5">Â every time we reach the top of the loop, before we run any of the code inside. If that expression is true, then we run the code inside. Finally, after we run the code inside, we useÂ </span><span class="s7">i++</span><span class="s5">Â to add one toÂ </span><span class="s7">i</span><span class="s5">, and the loop repeats.</span></li>
    <li class="li5"><span class="s2"></span><span class="s5">TheÂ </span><span class="s7">for</span><span class="s5">Â loop is more elegant than aÂ </span><span class="s7">while</span><span class="s5">Â loop in this case, since everything related to the loop is in the same line, and only the code we actually want to run multiple times is inside the loop.</span></li>
  </ul>
  <li class="li4"><span class="s2"></span><span class="s5">Notice that for many of these lines of code, likeÂ </span><span class="s7">if</span><span class="s5">Â conditions andÂ </span><span class="s7">for</span><span class="s5">Â loops, we donâ€™t put a semicolon at the end. This is just how the language of C was designed, many years ago, and a general rule is that only lines for actions or verbs have semicolons at the end.<br>
</span></li>
</ul>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s3"><a href="https://cs50.harvard.edu/x/2021/notes/1/#abstraction"><b>Abstraction</b><span class="s4"><b></b></span></a></span></h2>
<ul class="ul1">
  <li class="li4"><span class="s2"></span><span class="s5">We can write a program that printsÂ </span><span class="s7">meow</span><span class="s5">three times:<br>
`#include &lt;stdio.h&gt;<br>
int main(void) { printf("meow\n"); printf("meow\n"); printf("meow\n"); }`<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">We could use aÂ </span><span class="s7">for</span><span class="s5">Â loop, so we donâ€™t have to copy and paste so many lines:<br>
`#include &lt;stdio.h&gt;<br>
int main(void) { for (int i = 0; i &lt; 3; i++) { printf("meow\n"); } }`<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">We can move theÂ </span><span class="s7">printf</span><span class="s5">Â line to its own function, like our own puzzle piece:<br>
`#include &lt;stdio.h&gt;<br>
void meow(void) { printf("meow\n"); }<br>
int main(void) { for (int i = 0; i &lt; 3; i++) { meow(); } }`</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s2"></span><span class="s5">We defined a function,Â </span><span class="s7">meow</span><span class="s5">, above ourÂ </span><span class="s7">main</span><span class="s5">Â function.</span></li>
  </ul>
  <li class="li4"><span class="s2"></span><span class="s5">But conventionally, ourÂ </span><span class="s7">main</span><span class="s5">Â function should be the first function in our program, so we need a few more lines:<br>
`#include &lt;stdio.h&gt;<br>
void meow(void);<br>
int main(void) { for (int i = 0; i &lt; 3; i++) { meow(); } }<br>
void meow(void) { printf("meow\n"); }`</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s2"></span><span class="s5">It turns out that we need to declare ourÂ </span><span class="s7">meow</span><span class="s5">Â function first with aÂ <b>prototype</b>, before we use it inÂ </span><span class="s7">main</span><span class="s5">, and actually define it after. The compiler reads our source code from top to bottom, so it needs to know thatÂ </span><span class="s7">meow</span><span class="s5">Â will exist later in the file.</span></li>
  </ul>
  <li class="li4"><span class="s2"></span><span class="s5">We can even change ourÂ </span><span class="s7">meow</span><span class="s5">Â function to take in some input,Â </span><span class="s7">n</span><span class="s5">, and meowÂ </span><span class="s7">n</span><span class="s5">times:<br>
`#include &lt;stdio.h&gt;<br>
void meow(int n);<br>
int main(void) { meow(3); }<br>
void meow(int n) { for (int i = 0; i &lt; n; i++) { printf("meow\n"); } }`</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s2"></span><span class="s5">TheÂ </span><span class="s7">void</span><span class="s5">Â before theÂ </span><span class="s7">meow</span><span class="s5">function means that it doesnâ€™t return a value, and likewise inÂ </span><span class="s7">main</span><span class="s5">we canâ€™t do anything with the result ofÂ </span><span class="s7">meow</span><span class="s5">, so we just call it.</span></li>
  </ul>
  <li class="li4"><span class="s2"></span><span class="s5">The abstraction here leads to better design, since we now have the flexibility to reuse ourÂ </span><span class="s7">meow</span><span class="s5">Â function in multiple places in the future.<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">Letâ€™s look at another example of abstraction,Â </span><span class="s7">get_positive_int.c</span><span class="s5">:<br>
`#include &lt;cs50.h&gt; #include &lt;stdio.h&gt;<br>
int get_positive_int(void);<br>
int main(void) { int i = get_positive_int(); printf("%i\n", i); }<br>
// Prompt user for positive integer int get_positive_int(void) { int n; do { n = get_int("Positive Integer: "); } while (n &lt; 1); return n; }`</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s2"></span><span class="s5">We have our own function that callsÂ </span><span class="s7">get_int</span><span class="s5">Â repeatedly until we have some integer thatâ€™sÂ <i>not</i>Â less than 1. With a do-while loop, our program will do something first, then check some condition, and repeat while the condition is true. A while loop, on the other hand, will check the condition first.</span></li>
    <li class="li5"><span class="s2"></span><span class="s5">We need to declare our integerÂ </span><span class="s7">n</span><span class="s5">outside the do-while loop, since we need to use it after the loop ends. TheÂ <b>scope</b>Â of a variable in C refers to the context, or lines of code, within which it exists. In many cases, this will be the curly braces surrounding the variable.</span></li>
    <li class="li5"><span class="s2"></span><span class="s5">Notice that the functionÂ </span><span class="s7">get_positive_int</span><span class="s5">Â now starts withÂ </span><span class="s7">int</span><span class="s5">, indicating that it has a return value of typeÂ </span><span class="s7">int</span><span class="s5">, and inÂ </span><span class="s7">main</span><span class="s5">Â we indeed store it inÂ </span><span class="s7">i</span><span class="s5">Â after callingÂ </span><span class="s7">get_positive_int()</span><span class="s5">. InÂ </span><span class="s7">get_positive_int</span><span class="s5">, we have a new keyword,Â </span><span class="s7">return</span><span class="s5">, to return the valueÂ </span><span class="s7">n</span><span class="s5">Â to wherever the function was called.</span></li>
  </ul>
</ul>
<h2 style="margin: 0.0px 0.0px 14.9px 0.0px; font: 18.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s3"><a href="https://cs50.harvard.edu/x/2021/notes/1/#mario"><b>Mario</b><span class="s4"><b></b></span></a></span></h2>
<ul class="ul1">
  <li class="li4"><span class="s2"></span><span class="s5">We might want a program that prints part of a screen from a video game like Super Mario Bros. InÂ </span><span class="s7">mario.c</span><span class="s5">, we can print four question marks, simulating blocks:<br>
`#include &lt;stdio.h&gt;<br>
int main(void) { printf("????\n"); }`<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">With a loop, we can print a number of question marks, following them with a single new line after the loop:<br>
`#include &lt;stdio.h&gt;<br>
int main(void) { for (int i = 0; i &lt; 4; i++) { printf("?"); } printf("\n"); }`<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">We can get a positive integer from the user, and print out that number of question marks, by usingÂ </span><span class="s7">n</span><span class="s5">Â for our loop:<br>
`#include &lt;cs50.h&gt; #include &lt;stdio.h&gt;<br>
int main(void) { // Get positive integer from user int n; do { n = get_int("Width: "); } while (n &lt; 1);<br>
</span><span class="s7"><span class="Apple-converted-space">Â  </span>// Print out that many question marks</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>for (int i = 0; i &lt; n; i++)</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>{</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  Â  Â  </span>printf("?");</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>}</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><span class="Apple-converted-space">Â  </span>printf("\\n");</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><br>
</span><span class="s9">}`<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">And we can print a two-dimensional set of blocks with nested loops, one inside the other:<br>
`#include &lt;cs50.h&gt; #include &lt;stdio.h&gt;<br>
int main(void) { for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; 3; j++) { printf("#"); } printf("\n"); } }`</span></li>
  <ul class="ul2">
    <li class="li5"><span class="s2"></span><span class="s5">We have two nested loops, where the outer loop usesÂ </span><span class="s7">i</span><span class="s5">Â to do everything inside 3 times, and the inner loop usesÂ </span><span class="s7">j</span><span class="s5">, a different variable, to do something 3 times for each ofÂ <i>those</i>Â times. In other words, the outer loop prints 3 â€œrowsâ€, or lines, ending each of them with a new line, and the inner loop prints 3 â€œcolumnsâ€, orÂ </span><span class="s7">#</span><span class="s5">Â characters,Â <i>without</i>Â a new line.</span></li>
  </ul>
</ul>
<h1 style="margin: 0.0px 0.0px 16.1px 0.0px; font: 24.0px Times; color: #0000e9; -webkit-text-stroke: #0000e9"><span class="s3"><a href="https://cs50.harvard.edu/x/2021/notes/1/#memory-imprecision-and-overflow"><b>Memory, imprecision, and overflow</b><span class="s11"><b></b></span></a></span></h1>
<ul class="ul1">
  <li class="li4"><span class="s2"></span><span class="s5">Our computer has memory, in hardware chips called RAM, random-access memory. Our programs use that RAM to store data while theyâ€™re running, but that memory is finite.<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">WithÂ </span><span class="s7">imprecision.c</span><span class="s5">, we can see what happens when we use floats:<br>
`#include &lt;cs50.h&gt; #include &lt;stdio.h&gt;<br>
int main(void) { float x = get_float("x: "); float y = get_float("y: ");<br>
</span><span class="s7"><span class="Apple-converted-space">Â  </span>printf("%.50f\\n", x / y);</span></li>
  <li class="li6"><span class="s2"></span><span class="s5"><br>
</span><span class="s9">}`</span></li>
  <ul class="ul2">
    <li class="li4"><span class="s2"></span><span class="s5">WithÂ </span><span class="s7">%.50f</span><span class="s5">, we can specify the number of decimal places displayed.<br>
</span></li>
    <li class="li8"><span class="s10"></span><span class="s9">Hmm, now we get â€¦<br>
</span><span class="s5">x: 1 y: 10 0.10000000149011611938476562500000000000000000000000</span><span class="s9"><br>
</span></li>
    <li class="li4"><span class="s2"></span><span class="s5">It turns out that this is calledÂ <b>floating-point imprecision</b>, where we donâ€™t have enough bits to store all possible values. With a finite number of bits for aÂ </span><span class="s7">float</span><span class="s5">, we canâ€™t represent all possible real numbers (of which there are anÂ <i>infinite</i>Â number of), so the computer has to store the closest value it can. And this can lead to problems where even small differences in value add up, unless the programmer uses some other way to represent decimal values as accurately as needed.<br>
</span></li>
  </ul>
  <li class="li4"><span class="s2"></span><span class="s5">Last week, when we had three bits and needed to count higher than seven (orÂ </span><span class="s7">111</span><span class="s5">), we added another bit to get eight,Â </span><span class="s7">1000</span><span class="s5">. But if we only had three bits available, we wouldnâ€™t have a place for the extraÂ </span><span class="s7">1</span><span class="s5">. It would disappear and we would be back atÂ </span><span class="s7">000</span><span class="s5">. This problem is calledÂ <b>integer overflow</b>, where an integer can only be so big before it runs out of bits.<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">The Y2K problem arose because many programs stored the calendar year with just two digits, like 98 for 1998, and 99 for 1999. But when the year 2000 approached, the programs had to store only 00, leading to confusion between the years 1900 and 2000.<br>
</span></li>
  <li class="li4"><span class="s2"></span><span class="s5">In 2038, weâ€™ll also run out of bits to track time, since many years ago some humans decided to use 32 bits as the standard number of bits to count the number of seconds since January 1st, 1970. But with 32 bits representing only positive numbers, we can only count up to about four billion, and in 2038 weâ€™ll reach that limit unless we upgrade the software in all of our computer systems.<br>
</span></li>
</ul>
</body>
</html>
Ytext/htmlUutf-8_file:///index.htmlP    ( : P n } ”ı—ı¡ı§ı¼                           ı½